"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TunnelCluster = void 0;
const tslib_1 = require("tslib");
const node_net_1 = tslib_1.__importDefault(require("node:net"));
const tunnel_common_1 = require("@mondaydotcomorg/tunnel-common");
const HeaderHostTransformer_1 = require("./HeaderHostTransformer");
const rxjs_1 = require("rxjs");
const node_crypto_1 = require("node:crypto");
class TunnelCluster {
    constructor(opts) {
        this.opts = opts;
        this.$open = new rxjs_1.Subject();
        this.$error = new rxjs_1.Subject();
        this.$dead = new rxjs_1.Subject();
        this.$request = new rxjs_1.Subject();
        this.localProtocol = 'http';
        this.connLocal = (remote, tunnelId) => {
            var _a;
            const logger = (_a = this.logger) === null || _a === void 0 ? void 0 : _a.child({ tunnelId });
            if (remote.destroyed) {
                logger === null || logger === void 0 ? void 0 : logger.debug('remote destroyed');
                this.$dead.next({ tunnelId });
                return;
            }
            logger === null || logger === void 0 ? void 0 : logger.debug('connecting locally to %s://%s:%d', this.localProtocol, this.localHost, this.opts.localPort);
            remote.pause();
            // connection to local http server
            const local = node_net_1.default.connect(this.opts.localPort, this.localHost);
            const remoteClose = () => {
                logger === null || logger === void 0 ? void 0 : logger.debug('remote close');
                this.$dead.next({ tunnelId });
                local.end();
            };
            remote.once('close', remoteClose);
            // TODO some languages have single threaded servers which makes opening up
            // multiple local connections impossible. We need a smarter way to scale
            // and adjust for such instances to avoid beating on the door of the server
            local.once('error', (err) => {
                logger === null || logger === void 0 ? void 0 : logger.debug('local error %s', err.message);
                local.end();
                remote.removeListener('close', remoteClose);
                if (!(0, tunnel_common_1.hasCode)(err) || err.code !== 'ECONNREFUSED' && err.code !== 'ECONNRESET') {
                    remote.end();
                    return;
                }
                // retrying connection to local server
                setTimeout(() => this.connLocal(remote, tunnelId), 1000);
            });
            local.once('connect', () => {
                logger === null || logger === void 0 ? void 0 : logger.debug('connected locally');
                remote.resume();
                let stream = remote;
                // if user requested specific local host
                // then we use host header transform to replace the host header
                if (this.opts.localHost) {
                    logger === null || logger === void 0 ? void 0 : logger.debug('transform Host header to %s', this.opts.localHost);
                    stream = remote.pipe(new HeaderHostTransformer_1.HeaderHostTransformer({ host: this.opts.localHost }));
                }
                stream.pipe(local).pipe(remote);
                // when local closes, also get a new remote
                local.once('close', (hadError) => {
                    logger === null || logger === void 0 ? void 0 : logger.debug('local connection closed [error: %s]', hadError);
                });
            });
        };
        this.logger = this.opts.logger;
    }
    get remoteHostOrIp() {
        return this.opts.remoteIp || this.opts.remoteHost;
    }
    get localHost() {
        return this.opts.localHost || 'localhost';
    }
    open() {
        var _a;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const tunnelId = TunnelCluster.getRandomTunnelId();
            const logger = (_a = this.logger) === null || _a === void 0 ? void 0 : _a.child({ tunnelId });
            logger === null || logger === void 0 ? void 0 : logger.debug('establishing tunnel %s://%s:%s <> %s:%s', this.localProtocol, this.localHost, this.opts.localPort, this.remoteHostOrIp, this.opts.remotePort);
            // connection to tunnel server
            const remote = node_net_1.default.connect({
                host: this.remoteHostOrIp,
                port: this.opts.remotePort,
            });
            remote.setKeepAlive(true);
            remote.on('error', (err) => {
                logger === null || logger === void 0 ? void 0 : logger.error('got remote connection error %s', err.message);
                remote.end();
                // emit connection refused errors immediately, because they
                // indicate that the tunnel can't be established.
                if ((0, tunnel_common_1.hasCode)(err) && err.code === 'ECONNREFUSED') {
                    this.$error.next(new Error(`${tunnelId} connection refused: ${this.remoteHostOrIp}:${this.opts.remotePort} (check your firewall settings)`));
                }
            });
            remote.on('data', (data) => {
                const match = data.toString().match(/^(\w+) (\S+)/);
                if (match) {
                    this.$request.next({
                        method: match[1],
                        path: match[2],
                    });
                }
            });
            // tunnel is considered open when remote connects
            return new Promise((resolve) => {
                remote.once('connect', () => {
                    this.$open.next({ socket: remote, tunnelId });
                    resolve(remote);
                    this.connLocal(remote, tunnelId);
                });
            });
        });
    }
    static getRandomTunnelId() {
        return (0, node_crypto_1.randomUUID)().substring(0, 6);
    }
}
exports.TunnelCluster = TunnelCluster;
//# sourceMappingURL=TunnelCluster.js.map