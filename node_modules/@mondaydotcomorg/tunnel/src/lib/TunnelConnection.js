"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TunnelConnection = void 0;
const tslib_1 = require("tslib");
const axios_1 = tslib_1.__importStar(require("axios"));
const TunnelCluster_1 = require("./TunnelCluster");
const operators_1 = require("rxjs/operators");
const rxjs_1 = require("rxjs");
const constants_1 = require("../constants");
const RETRY_MS = 1000;
class TunnelConnection {
    constructor(opts) {
        this.opts = opts;
        this.$open = new rxjs_1.Subject();
        this.$error = new rxjs_1.Subject();
        this.closeSubject = new rxjs_1.BehaviorSubject(false);
        this.$close = this.closeSubject.asObservable().pipe((0, operators_1.skipWhile)((x) => !x), (0, operators_1.first)());
        this.$request = new rxjs_1.Subject();
        this.logger = opts.logger;
    }
    get url() {
        var _a;
        return (_a = this.info) === null || _a === void 0 ? void 0 : _a.url;
    }
    open() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const info = yield (0, rxjs_1.lastValueFrom)((0, rxjs_1.from)(this.init()).pipe((0, operators_1.retry)({
                delay: (error, retryCount) => {
                    var _a;
                    if (error instanceof axios_1.AxiosError) {
                        if (error.code !== axios_1.AxiosError.ERR_BAD_REQUEST) {
                            (_a = this.logger) === null || _a === void 0 ? void 0 : _a.warn('retrying connection to the server (attempt %d)...', retryCount);
                            return (0, rxjs_1.timer)(RETRY_MS);
                        }
                        return (0, rxjs_1.throwError)(() => {
                            var _a, _b;
                            return new Error(typeof ((_a = error.response) === null || _a === void 0 ? void 0 : _a.data) === 'string'
                                ? (_b = error.response) === null || _b === void 0 ? void 0 : _b.data
                                : error.message);
                        });
                    }
                    return (0, rxjs_1.throwError)(() => error);
                },
            })));
            if (!info) {
                throw new Error("tunnel server didn't return any information");
            }
            this.establish(info);
            return info;
        });
    }
    close() {
        this.closeSubject.next(true);
    }
    getInfo(body) {
        var _a;
        const { id, ip, port, url, maxConnCount } = body;
        const { host = constants_1.TUNNEL_DEFAULT_HOST, port: localPort, localHost, } = this.opts;
        if (!url) {
            throw new Error('server did not return a tunnel URL');
        }
        return {
            clientId: id,
            url,
            maxConnCount: maxConnCount || 1,
            remoteHost: (_a = new URL(host).hostname) !== null && _a !== void 0 ? _a : undefined,
            remoteIp: ip,
            remotePort: port,
            localPort,
            localHost,
        };
    }
    // initialize connection
    // callback with connection info
    init() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { host = constants_1.TUNNEL_DEFAULT_HOST, subdomain } = this.opts;
            const logger = this.logger;
            const uri = subdomain
                ? `${host}/api/tunnels/${subdomain}`
                : `${host}/api/tunnels`;
            logger === null || logger === void 0 ? void 0 : logger.debug('retrieving tunnel information from %s', uri);
            const res = yield axios_1.default.post(uri, {
                responseType: 'json',
            });
            this.info = this.getInfo(res.data);
            logger === null || logger === void 0 ? void 0 : logger.debug('got tunnel information: %o', this.info);
            return this.info;
        });
    }
    establish(info) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const tunnelCluster = (this.tunnelCluster = new TunnelCluster_1.TunnelCluster(Object.assign(Object.assign({}, info), { logger: this.logger })));
            // re-emit socket error
            tunnelCluster.$error.subscribe((err) => {
                var _a;
                (_a = this.logger) === null || _a === void 0 ? void 0 : _a.debug('got socket error: %s', err.message);
                this.$error.next(err);
            });
            let tunnelCount = 0;
            // track open count
            tunnelCluster.$open.subscribe(({ socket, tunnelId }) => {
                var _a;
                tunnelCount++;
                (_a = this.logger) === null || _a === void 0 ? void 0 : _a.debug({ tunnelId }, 'tunnel open [total: %d]', tunnelCount);
                const closeSub = this.$close.subscribe(() => socket.destroy());
                socket.once('close', () => {
                    closeSub.unsubscribe();
                });
            });
            // when a tunnel dies, open a new one
            tunnelCluster.$dead.subscribe(({ tunnelId }) => {
                var _a;
                tunnelCount--;
                (_a = this.logger) === null || _a === void 0 ? void 0 : _a.debug({ tunnelId }, 'tunnel dead [total: %d]', tunnelCount);
                this.closeSubject
                    .pipe((0, operators_1.first)(), (0, operators_1.filter)((x) => !x))
                    .subscribe(() => {
                    var _a;
                    (_a = this.tunnelCluster) === null || _a === void 0 ? void 0 : _a.open();
                });
            });
            tunnelCluster.$request.subscribe((req) => {
                this.$request.next(req);
            });
            yield (0, rxjs_1.lastValueFrom)((0, rxjs_1.range)(0, info.maxConnCount).pipe((0, operators_1.mergeMap)(() => (0, rxjs_1.from)(tunnelCluster.open()))));
        });
    }
}
exports.TunnelConnection = TunnelConnection;
//# sourceMappingURL=TunnelConnection.js.map